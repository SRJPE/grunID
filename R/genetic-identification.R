#' @title Add Thresholds to Database
#' @param con a connection the database
#' @param thresholds a thresholds table to use as insert data, this table is generated by `generate_threshold`
#' @param .control_id the id to use as the control for thresholds
#' @details
#' Additional details...
#'
#' @export
#' @md
add_plate_thresholds <- function(con, thresholds, destination_table, results_table, .control_id = "EBK") {

  if (!DBI::dbIsValid(con)) {
    stop("Connection argument does not have a valid connection the run-id database.
         Please try reconnecting to the database using 'DBI::dbConnect'",
         call. = FALSE)
  }

  plate_run <- unique(thresholds$plate_run_id)
  runtime <- unique(thresholds$runtime)
  if (length(plate_run) > 1) {
    stop("TODO")
  }

  if (length(runtime) > 1) {
    stop("TODO")
  }

  # check if the plate run already exists in the assay_results
  this_plate_run_exists_in_results <- nrow(
    dplyr::collect(dplyr::tbl(con, "assay_result") |> dplyr::filter(plate_run_id == plate_run))
  )

  if (this_plate_run_exists_in_results) {
    stop("the plate run you are trying to upload already exists in the database", call. = FALSE)
  }

  detection_results <- dplyr::tbl(con, results_table) |>
    dplyr::filter(plate_run_id == plate_run,
                  sample_id != .control_id,
                  time == runtime) |>
    dplyr::collect() |>
    dplyr::left_join(thresholds, by = c("assay_id" = "assay_id", "plate_run_id" = "plate_run_id")) |>
    dplyr::mutate(positive_detection = raw_fluorescence > threshold) |>
    dplyr::select(sample_id, assay_id, raw_fluorescence, well_location,
                  threshold, positive_detection, plate_run_id, sub_plate)

  assay_results_added <- insert_detection_results(con, detection_results, table = destination_table)

  return(assay_results_added)

}

insert_detection_results <- function(con, detection_results, table = c("assay_result", "external_assay_result")) {

  destination_table <- match.arg(table)

  query <- glue::glue_sql("
  INSERT INTO {`destination_table`} (sample_id, assay_id, raw_fluorescence, threshold,
                            positive_detection, plate_run_id, sub_plate, well_location)
  VALUES (
          {detection_results$sample_id},
          {detection_results$assay_id},
          {detection_results$raw_fluorescence},
          {detection_results$threshold},
          {detection_results$positive_detection},
          {detection_results$plate_run_id}::int,
          {detection_results$sub_plate}::int,
          {detection_results$well_location}
  );", .con = con)

  assay_results_added <- purrr::map_dbl(query, function(q) {
    DBI::dbExecute(con, q)
  },
  .progress = list(
    type = "iterator",
    clear = FALSE,
    name = "inserting threshold result into database"
  ))

  return(sum(assay_results_added))
}

insert_detection_results <- function(con, detection_results, table = c("assay_result", "external_assay_result")) {

  destination_table <- match.arg(table)

  query <- glue::glue_sql("
  INSERT INTO {`destination_table`} (sample_id, assay_id, raw_fluorescence, threshold,
                            positive_detection, plate_run_id, sub_plate, well_location)
  VALUES (
          {detection_results$sample_id},
          {detection_results$assay_id},
          {detection_results$raw_fluorescence},
          {detection_results$threshold},
          {detection_results$positive_detection},
          {detection_results$plate_run_id}::int,
          {detection_results$sub_plate}::int,
          {detection_results$well_location}
  );", .con = con)

  assay_results_added <- purrr::map_dbl(query, function(q) {
    DBI::dbExecute(con, q)
  },
  .progress = list(
    type = "iterator",
    clear = FALSE,
    name = "inserting threshold result into database"
  ))

  return(sum(assay_results_added))
}


#' @title Determine Run identifcation after Early and Late Assays
#' @param con a database connection
#' @param sample_id the sample id to perform run identification on
#' @param strategy the strategy to use when multi same assays are found for a sample see "details" for more
#' @details
#' The system allows users to submit as many assays per sample as desired, however at the end in order to assign
#' a genetic run type to a sample a single early, late, spring, and winter assay must be used. The selection
#' strategy gives the function a way to select when it finds multiple assays for a sample.
#'
#' - "positive priority" - will choose the the positive results from the available assays needed
#' - "recent priority" - will choose the most recent assays from the available assays needed.
#' @export
#' @md
ots_early_late_detection <- function(con, sample_id, results_table,
                                     selection_strategy = c("recent priority", "positive priority")) {
  selection_strategy <- match.arg(selection_strategy)

  # gather all data that needs to be written to the database
  results <- list()

  # get all results that match this sample id
  # we filter to just the sample that have an active plate run associated with them
  assay_results <- tbl(con, results_table) |>
    filter(sample_id %in% !!sample_id, active == TRUE) |>
    collect()

  # get all the assays run for each
  assays_existing_for_sample <- assay_results |>
    select(sample_id, assay_id) |>
    group_by(sample_id) |>
    summarise(
      val = sum(assay_id)
    ) |>
    mutate(
      assay_state = case_when(
        val == 3 ~ "both",
        val == 2 ~ "two",
        val == 1 ~ "one",
        TRUE ~ "neither"
      )
    )

  # get subset of samples for which there needs to be additional assay on
  samples_needing_assay_one <- assays_existing_for_sample |> filter(assay_state == "two")
  samples_needing_assay_two <- assays_existing_for_sample |> filter(assay_state != "one")

  # the subset that is ready to get assignment
  samples_good_to_go <- assays_existing_for_sample |> filter(assay_state == "both")

  results$samples_need_one <- samples_needing_assay_one
  results$samples_need_two <- samples_needing_assay_two

  # check for what assays are needed
  # if (length(assay_needed_not_found) > 0) {
  #
  #   if (length(assay_needed_not_found) == 2) { # both are missing
  #
  #     return(list(
  #       sample_id = sample_id,
  #       status_code = "created",
  #       run_type = NA_character_,
  #       early_plate = NA,
  #       late_plate = NA
  #     ))
  #   } else if (assay_needed_not_found == 1) {
  #     return(list(
  #       sample_id = sample_id,
  #       status_code = "ots28 in progress",
  #       run_type = NA_character_,
  #       early_plate = NA,
  #       late_plate = NA
  #     ))
  #   } else if (assay_needed_not_found == 2){
  #     return(list(
  #       sample_id = sample_id,
  #       status_code = "ots28 in progress",
  #       run_type = NA_character_,
  #       early_plate = NA,
  #       late_plate = NA
  #     ))
  #   }
  # }

  ots_early <- assay_results |> filter(assay_id == 1)

  if (nrow(collect(ots_early)) > 1) {
    cli::cli_alert_info("using '{selection_strategy}' to identify a unique assay run")
    if (selection_strategy == "positive priority") {
      ots_early_priority_results <-
        ots_early |> filter(positive_detection) |>
        arrange(desc(created_at)) |>
        head(1) |>
        collect()
      if (nrow(ots_early_priority_results) > 1) {
        cli::cli_abort(c(
          "x" = "'positive priority' did not identify a unique assay run",
          "i" = "try a different strategy or pass plate id of run to use for identification"
        ))
      }
    } else if (selection_strategy == "recent priority") {
      ots_early_priority_results <-
        ots_early |> arrange(desc(created_at)) |>
        head(1) |>
        collect()
    }
  } else {
    ots_early_priority_results <- collect(ots_early)
  }




  ots_late <- assay_results |> filter(assay_id == 2)

  if (nrow(collect(ots_late)) > 1) {
    cli::cli_alert_info("using '{selection_strategy}' to identify a unique assay run")
    if (selection_strategy == "positive priority") {
      ots_late_priority_results <-
        ots_late |> filter(positive_detection) |>
        collect()
      # if this results in more than one, abort with error
      if (nrow(ots_late_priority_results) > 1) {
        cli::cli_abort(c(
          "x" = "'positive priority' did not identify a unique assay run",
          "i" = "try a different strategy or pass plate id of run to use for identification"
        ))
      }
      # if this results in no positive then return
      else if (nrow(ots_late_priority_results) == 0) {
        cli::cli_abort(c(
          "x" = "'positive priority' did not yield any results",
          "i" = "no results from this query typically means that there are no positive detections for this sample, you can use 'recent priority' to run genetic identification on whatever the most recent sample results are."
        ))
      }
    } else if (selection_strategy == "recent priority") {
      ots_late_priority_results <-
        ots_late |> arrange(desc(created_at)) |>
        head(1) |>
        collect()
    }
  } else {
    ots_late_priority_results <- collect(ots_late)
  }

  # positive late negative early --> late/fall run
  if (!ots_early_priority_results$positive_detection && ots_late_priority_results$positive_detection) {
    return(list(sample_id = sample_id, status_code = "analysis complete", run_type="FAL", early_plate = ots_early_priority_results$plate_run_id, late_plate = ots_late_priority_results$plate_run_id))
  }
  # positive late and positive early --> HET more testing needed
  else if (ots_early_priority_results$positive_detection && ots_late_priority_results$positive_detection) {
    return(list(sample_id = sample_id, status_code = "analysis complete", run_type="EL-HET", early_plate = ots_early_priority_results$plate_run_id, late_plate = ots_late_priority_results$plate_run_id))
  }
  # negative late and positive early --> SPW need ots 16
  else if (ots_early_priority_results$positive_detection && !ots_late_priority_results$positive_detection) {
    return(list(sample_id = sample_id, status_code = "need ots16", run_type = "SPW", early_plate = ots_early_priority_results$plate_run_id, late_plate = ots_late_priority_results$plate_run_id))
  }
  # negative late and negative early --> UNK
  else if (!ots_early_priority_results$positive_detection && !ots_late_priority_results$positive_detection){
    return(list(sample_id = sample_id, status_code = "EL-failed", run_type = "UNK", early_plate = ots_early_priority_results$plate_run_id, late_plate = ots_late_priority_results$plate_run_id))
  }
  else {
    cli::cli_abort(c("x" = "uknown combination of test results for {sample_id}, unable to proceed"))
  }

}


#' @title Determine Run identifcation after Spring and Winter Assays
#' @param con a database connection
#' @param sample_id the sample id to perform run identification on
#' @param strategy the strategy to use when multi same assays are found for a sample see "details" for more
#' @details
#' The system allows users to submit as manu assays per sample as desired, however at the end in order to assign
#' a genetic run type to a sample a single early, late, spring, and winter assay must be used. The selection
#' strategy gives the function a way to select when it finds multiple assays for a sample.
#'
#' - "positive priority" - will choose the the postitive results from the available assays needed
#' - "recent prioritt" - will choose the most recent assays from the available assays needed.
#' @export
#' @md
ots_winter_spring_detection <- function(con, sample_id, results_table,
                                        selection_strategy = c("positive priority", "recent priority")) {
  selection_strategy <- match.arg(selection_strategy)


  assay_results <- tbl(con, results_table) |>
    filter(sample_id == !!sample_id, active == TRUE)

  assays_for_existing_for_sample <- assay_results |> dplyr::distinct(assay_id) |> dplyr::pull()
  assays_3_for_sample <- assay_results |> dplyr::filter(assay_id == 3) |> dplyr::collect()
  assays_4_for_sample <- assay_results |> dplyr::filter(assay_id == 4) |> dplyr::collect()

  if ((nrow(assays_3_for_sample) == 0) && (nrow(assays_4_for_sample) == 0)) {

    return(list(
      sample_id = sample_id,
      status_code = "need ots16",
      run_type = "SPW",
      spring_plate_id = NA_integer_,
      winter_plate_id = NA_integer_
    ))
  } else if (nrow(assays_3_for_sample) == 0 && (nrow(assays_4_for_sample) > 0)) {

    return(list(
      sample_id = sample_id,
      status_code = "ots16 inprogress",
      run_type = "SPW",
      spring_plate_id = NA_integer_,
      winter_plate_id = NA_integer_
    ))
  } else if (nrow(assays_4_for_sample) == 0 && (nrow(assays_3_for_sample) > 0)) {
    return(list(
      sample_id = sample_id,
      status_code = "ots16 inprogress",
      run_type = NA_character_,
      spring_plate_id = NA_integer_,
      winter_plate_id = NA_integer_
    ))
  }


  # at this point the sample has both 3 an 4, we do selection strategy here
  ots_spring <- assay_results |> dplyr::filter(assay_id == 3)


  if (nrow(collect(ots_spring)) > 1) {
    cli::cli_alert_info("using '{selection_strategy}' to identify a unique assay run")
    if (selection_strategy == "positive priority") {
      ots_spring_priority_results <-
        ots_spring |> filter(positive_detection) |>
        collect()
      if (nrow(ots_early_priority_results) > 1) {
        cli::cli_abort(c(
          "x" = "'positive priority' did not identify a unique assay run",
          "i" = "try a different strategy or pass plate id of run to use for identification"
        ))
      }
    } else if (selection_strategy == "recent priority") {
      ots_spring_priority_results <-
        ots_spring |> arrange(desc(created_at)) |>
        head(1) |>
        collect()
    }
  } else {
    ots_spring_priority_results <- collect(ots_spring)
  }




  ots_winter <- assay_results |> filter(assay_id == 4)

  if (nrow(collect(ots_winter)) > 1) {
    cli::cli_alert_info("using '{selection_strategy}' to identify a unique assay run")
    if (selection_strategy == "positive priority") {
      ots_winter_priority_results <-
        ots_winter |> filter(positive_detection) |>
        collect()
      if (nrow(ots_winter_priority_results) > 1) {
        cli::cli_abort(c(
          "x" = "'positive priority' did not identify a unique assay run",
          "i" = "try a different strategy or pass plate id of run to use for identification"
        ))
      }
    } else if (selection_strategy == "recent priority") {
      ots_winter_priority_results <-
        ots_winter |> arrange(desc(created_at)) |>
        head(1) |>
        collect()
    }
  } else {
    ots_winter_priority_results <- collect(ots_winter)
  }

  # positive winter and negative spring ---> WIN
  if (!ots_spring_priority_results$positive_detection && ots_winter_priority_results$positive_detection) {
    return(list(sample_id = sample_id, status_code = "analysis complete", run_type="WIN",
                winter_plate_id = ots_winter_priority_results$plate_run_id, spring_plate_id = ots_spring_priority_results$plate_run_id))
  }
  # positive winter and positive spring ---> HET
  else if (ots_spring_priority_results$positive_detection && ots_winter_priority_results$positive_detection) {
    return(list(sample_id = sample_id, status_code = "analysis complete", run_type="SW-HET",
                winter_plate_id = ots_winter_priority_results$plate_run_id, spring_plate_id = ots_spring_priority_results$plate_run_id))
  }
  # negative winter and positive spring --> SPR
  else if (ots_spring_priority_results$positive_detection && !ots_winter_priority_results$positive_detection) {
    return(list(sample_id = sample_id, status_code = "analysis complete", run_type = "SPR",
                winter_plate_id = ots_winter_priority_results$plate_run_id, spring_plate_id = ots_spring_priority_results$plate_run_id))
  }
  # both negative --> UNK
  else if (!ots_spring_priority_results$positive_detection && !ots_winter_priority_results$positive_detection){
    return(list(sample_id = sample_id, status_code = "SW-failed", run_type = "UNK",
                winter_plate_id = ots_winter_priority_results$plate_run_id, spring_plate_id = ots_spring_priority_results$plate_run_id))
  }


}


run_genetic_identification_v2 <- function(con, samples, plate_run_id) {
    res <- DBI::dbGetQuery(con,
                           glue::glue_sql("SELECT *
                                          FROM (
                                            SELECT *,
                                                   ROW_NUMBER() OVER (PARTITION BY sample_id, assay_id ORDER BY created_at DESC) as rn
                                            FROM assay_result
                                            WHERE active = true
                                          ) subquery
                                          WHERE rn = 1 and sample_id IN ({samples*});",
                                          .con = con)) |> as_tibble()


  sample_results <- res |>
    select(sample_id, assay_id, positive_detection) |>
    complete(sample_id, assay_id = 1:4) |>  # fill in the missing id's when needed
    pivot_wider(
      names_from = assay_id,
      values_from = positive_detection,
    ) |>
    rename("early" = `1`, "late" = `2`, "spring" = `3`, "winter" = `4`) |>
    mutate(sample_state = case_when(
      is.na(early) & !late & is.na(spring) & is.na(winter) ~ "UNK;ots28 in progress",
      is.na(early) & late & is.na(spring) & is.na(winter) ~ "UNK;ots28 in progress",
      early & is.na(late) & is.na(spring) & is.na(winter) ~ "UNK;ots28 in progress",
      !early & is.na(late) & is.na(spring) & is.na(winter) ~ "UNK;ots28 in progress",
      !early & late & is.na(spring) & is.na(winter) ~ "FAL;analysis complete", # positive late and negative early = Fall
      early & late & is.na(spring) & is.na(winter) ~ "EL-HET;need gtseq", # positive early and positive late = HET
      early & !late & is.na(spring) & is.na(winter) ~ "SPW;need ots16", # positive early and negative late = SPW
      !early & !late & is.na(spring) & is.na(winter) ~ "UNK;EL-failed", # negative early and negative late = FAIL
      early & !late & spring & is.na(winter) ~ "SPW;need ots16", #TODO: ots16 in progress
      is.na(early) & is.na(late) & spring & is.na(winter) ~ "SPW;need ots16",
      spring & winter ~ "SW-HET;need gtseq",
      !spring & winter ~ "WIN;analysis complete",
      spring & !winter ~ "SPR;analysis complete",
      !spring & !winter ~ "UNK;SW-failed"
    )) |>
    separate(sample_state, into=c("run", "sample_status"), sep = ";") |>
    mutate(
      sample_status = case_when(
        sample_status == "need ots16" & str_detect(sample_id, "KNL|TIS|DEL") ~ "need gtseq",
        TRUE ~ sample_status
      )
    )


  # update the sample status
  status_codes <- tbl(con, "status_code") |> collect()
  sample_results_for_status_inserts <-
    sample_results |> left_join(select(status_codes, status_code_name, id), by=c("sample_status"= "status_code_name")) |>
    mutate(plate_run_id = plate_run_id)
  values_clause <- glue::glue_collapse(glue::glue("('{sample_results_for_status_inserts$sample_id}', '{sample_results_for_status_inserts$id}', '{sample_results_for_status_inserts$plate_run_id}')"), sep = ", ")
  insert_statement <- glue::glue("INSERT INTO sample_status (sample_id, status_code_id, plate_run_id) values {values_clause}")

  status_codes_updated <- DBI::dbExecute(con, insert_statement)


  # update the genetics identification table
  run_types <- tbl(con, "run_type") |> collect()
  samples_results_for_genid_inserts <-
    sample_results |> left_join(select(run_types, id, code, run_name), by=c("run"="code")) |>
    mutate(
      early_plate_id = ifelse(is.na(early), NA_integer_, res[res$sample_id == sample_id & res$assay_id == 1, ]$plate_run_id),
      late_plate_id = ifelse(is.na(late), NA_integer_, res[res$sample_id == sample_id & res$assay_id == 2, ]$plate_run_id),
      spring_plate_id = ifelse(is.na(spring), NA_integer_, res[res$sample_id == sample_id & res$assay_id == 3, ]$plate_run_id),
      winter_plate_id = ifelse(is.na(winter), NA_integer_, res[res$sample_id == sample_id & res$assay_id == 4, ]$plate_run_id))

  insert_statement <- glue::glue_sql("INSERT INTO genetic_run_identification (sample_id, run_type_id, early_plate_id, late_plate_id, winter_plate_id, spring_plate_id)
                                 values (
                                 UNNEST(ARRAY[{samples_results_for_genid_inserts$sample_id*}]),
                                 UNNEST(ARRAY[{samples_results_for_genid_inserts$id*}]),
                                 UNNEST(ARRAY[{samples_results_for_genid_inserts$early_plate_id*}]),
                                 UNNEST(ARRAY[{samples_results_for_genid_inserts$late_plate_id*}]),
                                 UNNEST(ARRAY[{samples_results_for_genid_inserts$winter_plate_id*}]),
                                 UNNEST(ARRAY[{samples_results_for_genid_inserts$spring_plate_id*}])
                                 )
                                 ", .con = con)

  genetic_runs_assigned <- DBI::dbExecute(con, insert_statement)

  message(glue::glue("A total of {status_codes_updated} samples satus were updated, and a total of {genetic_runs_assigned} genetic runs were assinged/updated"))

  return(list(
    n_status_codes_updated = status_codes_updated,
    n_genetic_runs_assigned = genetic_runs_assigned
  ))
}


#' @title Run genetic identification
#' @param con a connection to the database
#' @param sample_id optional sample id to run identification on
#' @param location optional location to identification on
#' @param year optional year to identification on
#' @param selection_strategy a selection strategy to help resolve cases where many assays exists per sample
#' @export
run_genetic_identification <- function(con, sample_id = NULL, location = NULL, year = NULL, selection_strategy = "positive priority", plate_run_id,
                                       plate_comment, destination_table, sample_table, results_table,
                                       sample_status_table, layout_type) {

  # check for valid inputs and data -------------------------
  if (is.null(year)) {
    year <- as.integer(format(Sys.Date(), "%Y"))
  }

  if (!is.null(sample_id)) {

    sample_to_run_on <- dplyr::tbl(con, sample_table) |>
      dplyr::filter(id %in% sample_id) |>
      dplyr::collect()

    if (nrow(sample_to_run_on) == 0) {
      cli::cli_abort(c("x" = "location specified did not return any data"))
    }
  } else if (!is.null(location)) {

    query <- glue::glue_sql("select distinct(sample.id), sample_location.code from sample
    join sample_bin on sample.sample_bin_id = sample_bin.id
    join sample_event on sample_bin.sample_event_id = sample_event.id
    join sample_location on sample_event.sample_location_id = sample_location.id
where date_part('year', sample_event.first_sample_date) = {year} and sample_location.code = {location}", .con = con)

    res <- DBI::dbSendQuery(con, query)
    sample_to_run_on <- DBI::dbFetch(res)
    DBI::dbClearResult(res)

    if (nrow(sample_to_run_on) == 0) {
      cli::cli_abort(c("x" = "location specified did not return any data"))
    }
  }

  # run early/late detection on each sample -------------------
  early_late_resp <- purrr::map(
    sample_to_run_on$id, ~ots_early_late_detection(con, ., results_table = results_table, selection_strategy = selection_strategy),
    .progress = list(
      type = "iterator",
      name = "running early late detections",
      clear = FALSE
    ))

  early_late_resp_data <- parse_detection_results(early_late_resp)
  all_status_codes <- grunID::get_status_codes(con)
  all_run_type_id <- grunID::get_run_types(con)

  # updates status code to complete
  status_code_name_to_id <- all_status_codes$id
  names(status_code_name_to_id) <- all_status_codes$status_code_name

  # updates run type
  run_type_name_to_id <- all_run_type_id$id
  names(run_type_name_to_id) <- all_run_type_id$code


  el_failed_status_insert <- early_late_resp_data |>
    filter(status_code == "EL-failed")

  if (nrow(el_failed_status_insert) > 0) {
    el_failed_status_insert$comment <- plate_comment
    el_failed_status_insert$status_code_id <- status_code_name_to_id["EL-failed"]
    el_failed_status_insert$plate_run_id <- plate_run_id
    status_to_insert <- dplyr::select(el_failed_status_insert, sample_id, status_code_id, comment, plate_run_id)
    DBI::dbAppendTable(con, sample_status_table, status_to_insert)

    uknown_gen_insert <- early_late_resp_data |>
      dplyr::filter(status_code == "EL-failed")

    insert_gen_id_to_database(con, uknown_gen_insert, run_type_name_to_id, destination_table)

  }


  analysis_complete_status_insert <- early_late_resp_data |>
    dplyr::filter(status_code == "analysis complete")



  if (nrow(analysis_complete_status_insert) > 0) {

    analysis_complete_status_insert$comment <- plate_comment
    analysis_complete_status_insert$status_code_id <- status_code_name_to_id["analysis complete"]
    analysis_complete_status_insert$plate_run_id <- plate_run_id
    analysis_complete_status_insert <- dplyr::select(analysis_complete_status_insert, sample_id, status_code_id, comment, plate_run_id)
    DBI::dbAppendTable(con, sample_status_table, analysis_complete_status_insert)

    analysis_complete_gen_insert <- early_late_resp_data |>
      dplyr::filter(status_code == "analysis complete")

    insert_gen_id_to_database(con, analysis_complete_gen_insert, run_type_name_to_id, destination_table = destination_table)

  }

  # at this point we have inserted all of the samples that were complete
  # now check for status = "Created", some of these will need to have genetic id updated, specifically the UNK ones
  created_status_to_insert <-
    early_late_resp_data |> dplyr::filter(status_code == "created")

  if (nrow(created_status_to_insert) > 0) {

    created_status_to_insert$comment <- plate_comment
    created_status_to_insert$status_code_id <- status_code_name_to_id["created"]
    created_status_to_insert$plate_run_id <- plate_run_id
    created_status_to_insert <- dplyr::select(created_status_to_insert, sample_id, status_code_id, comment, plate_run_id)
    DBI::dbAppendTable(con, sample_status_table, created_status_to_insert)

    # for sample status with "created" the run type needs to be set to UNK so they can be discovered
    unknown_gen_to_insert <- early_late_resp_data |>
      filter(run_type == "UNK")

    if (nrow(unknown_gen_to_insert) > 0) {

      insert_gen_id_to_database(con, unknown_gen_to_insert, run_type_name_to_id, destination_table = destination_table)

    }
  }

  # OTS28 in progress / eihter assay 1 or 2 is not done


  ots28_inprogress_to_insert <- early_late_resp_data |>
    dplyr::filter(status_code == "ots28 in progress")


  if (nrow(ots28_inprogress_to_insert) > 0) {


    ots28_inprogress_to_insert$comment <- plate_comment
    ots28_inprogress_to_insert$status_code_id <- status_code_name_to_id["ots28 in progress"]
    ots28_inprogress_to_insert$plate_run_id <- plate_run_id
    ots28_inprogress_to_insert <- dplyr::select(ots28_inprogress_to_insert, sample_id, status_code_id, comment, plate_run_id)
    DBI::dbAppendTable(con, sample_status_table, ots28_inprogress_to_insert)

  }

  # needs ots 16 will be passed into function that tries to assign run based on assay 3 and 4
  ots16_in_progress_to_insert <- early_late_resp_data |>
    dplyr::filter(status_code == "need ots16")

  # TODO - what should we return in this case? For now just returning the dataframe with most info
  if (nrow(ots16_in_progress_to_insert) == 0) {
    return(early_late_resp_data)
  }

  # if (layout_type %in% c("split_plate_early_late", "split_plate_late_early")) {
  #   ots16_in_progress_to_insert$comment <- plate_comment
  #   ots16_in_progress_to_insert$status_code_id <- status_code_name_to_id["need ots16"]
  #   ots16_in_progress_to_insert$plate_run_id <- plate_run_id
  #   ots16_in_progress_to_insert <- dplyr::select(ots16_in_progress_to_insert, sample_id, status_code_id, comment, plate_run_id)
  #   DBI::dbAppendTable(con, sample_status_table, ots16_in_progress_to_insert)
  #   return (early_late_resp_data)
  # }

  spring_winter_resp <- purrr::map(
    ots16_in_progress_to_insert$sample_id , ~ots_winter_spring_detection(con, ., selection_strategy = selection_strategy, results_table = results_table),
    .progress = list(
      type = "iterator",
      name = "running spring/winter detections",
      clear = FALSE
    ))

  spring_winter_resp_data <- parse_spring_winter_detection_results(spring_winter_resp) |>
    dplyr::left_join(select(early_late_resp_data, sample_id, early_plate, late_plate), by = "sample_id")

  sw_failed_status_insert <- early_late_resp_data |>
    filter(status_code == "SW-failed")

  if (nrow(sw_failed_status_insert) > 0) {
    sw_failed_status_insert$comment <- plate_comment
    sw_failed_status_insert$status_code_id <- status_code_name_to_id["SW-failed"]
    sw_failed_status_insert$plate_run_id <- plate_run_id
    status_to_insert <- dplyr::select(sw_failed_status_insert, sample_id, status_code_id, comment, plate_run_id)
    DBI::dbAppendTable(con, sample_status_table, status_to_insert)

    uknown_gen_insert <- early_late_resp_data |>
      dplyr::filter(status_code == "SW-failed")

    insert_gen_id_to_database(con, uknown_gen_insert, run_type_name_to_id, destination_table)

  }


  sw_analysis_complete_status_insert <- spring_winter_resp_data |>
    dplyr::filter(status_code == "analysis complete")

  # if any of the detection results in gen id for spring or winter then update here
  if (nrow(sw_analysis_complete_status_insert) > 0) {

    sw_analysis_complete_status_insert$comment <- plate_comment
    sw_analysis_complete_status_insert$status_code_id <- status_code_name_to_id["analysis complete"]
    sw_analysis_complete_status_insert$plate_run_id <- plate_run_id
    sw_analysis_complete_status_insert <- dplyr::select(sw_analysis_complete_status_insert, sample_id, status_code_id, comment, plate_run_id)
    DBI::dbAppendTable(con, sample_status_table, sw_analysis_complete_status_insert)

    sw_analysis_complete_gen_insert <- spring_winter_resp_data |>
      dplyr::filter(status_code == "analysis complete")

    insert_gen_id_to_database(con, sw_analysis_complete_gen_insert, run_type_name_to_id, destination_table = destination_table)

  }

  # need ots 16
  ots16_need_inserts <- spring_winter_resp_data |>
    dplyr::filter(status_code == "need ots16")

  if (nrow(ots16_need_inserts) > 0) {
    ots16_need_inserts$comment <- plate_comment
    ots16_need_inserts$status_code_id <- status_code_name_to_id["need ots16"]
    ots16_need_inserts$plate_run_id <- plate_run_id
    ots16_need_inserts <- dplyr::select(ots16_need_inserts, sample_id, status_code_id, comment, plate_run_id)
    DBI::dbAppendTable(con, sample_status_table, ots16_need_inserts)

    spw_gen_to_insert <- spring_winter_resp_data |>
      filter(run_type == "SPW")

    if (nrow(spw_gen_to_insert) > 0) {
      insert_gen_id_to_database(con, spw_gen_to_insert, run_type_name_to_id, destination_table)
    }
  }

  # ots 16 in progress status updates
  ots16_inprogress_inserts <- spring_winter_resp_data |>
    dplyr::filter(status_code == "ots16 inprogress")

  if (nrow(ots16_inprogress_inserts) > 0 ) {
    ots16_inprogress_inserts$comment <- plate_comment
    ots16_inprogress_inserts$status_code_id <- status_code_name_to_id["ots16 inprogress"]
    ots16_inprogress_inserts$plate_run_id <- plate_run_id
    ots16_inprogress_inserts <- dplyr::select(ots16_inprogress_inserts, sample_id, status_code_id, comment)
    DBI::dbAppendTable(con, sample_status_table, ots16_inprogress_inserts)

    spw_gen_to_insert <- spring_winter_resp_data |>
      filter(run_type == "SPW")

    if (nrow(spw_gen_to_insert) > 0) {
      insert_gen_id_to_database(con, spw_gen_to_insert, run_type_name_to_id, destination_table = destination_table)
    }


  }



}





#' @keywords internal
insert_gen_id_to_database <- function(con, insert_data, run_lookups, destination_table) {
  # append cols required
  run_type_code <- insert_data$run_type
  insert_data$run_type_id = as.numeric(run_lookups[insert_data$run_type])
  insert_data <- dplyr::select(insert_data, tidyselect::any_of(c("sample_id", "run_type_id", "early_plate", "late_plate", "spring_plate_id", "winter_plate_id")))
  insert_data$updated_at <- lubridate::now(tzone = "UTC")

  purrr::walk(1:nrow(insert_data), function(row) {
    this_sample_id <- insert_data$sample_id[row]
    this_run_type_id <- insert_data$run_type_id[row]
    this_early_plate <- insert_data$early_plate[row]
    this_late_plate <- insert_data$late_plate[row]
    this_spring_plate_id <- insert_data$spring_plate_id[row]
    this_winter_plate_id <- insert_data$winter_plate_id[row]

    insert_statement <- if (run_type_code[row] %in% c("SPW", "SPR", "WIN")) {
      glue::glue_sql(
        "INSERT INTO {`destination_table`} (sample_id, run_type_id, early_plate_id, late_plate_id, spring_plate_id, winter_plate_Id, updated_at)
    VALUES
      ({this_sample_id}, {this_run_type_id}, {this_early_plate}, {this_late_plate}, {this_spring_plate_id}, {this_winter_plate_id}, CURRENT_TIMESTAMP AT TIME ZONE 'UTC');
    ",
        .con = con
      )
    } else {
      glue::glue_sql(
        "INSERT INTO {`destination_table`} (sample_id, run_type_id, early_plate_id, late_plate_id, updated_at)
    VALUES
      ({this_sample_id}, {this_run_type_id}, {this_early_plate}, {this_late_plate}, CURRENT_TIMESTAMP AT TIME ZONE 'UTC');
    ",
        .con = con
      )
    }

    DBI::dbExecute(con, insert_statement)
  })
}


parse_detection_results <- function(detection_results) {
  purrr::map_df(detection_results, function(x) {
    data.frame(sample_id = x$sample_id,
               status_code = x$status_code,
               run_type = x$run_type,
               early_plate = x$early_plate,
               late_plate = x$late_plate)
  })
}

parse_spring_winter_detection_results <- function(detection_results) {
  purrr::map_df(detection_results, function(x) {
    data.frame(sample_id = x$sample_id,
               status_code = x$status_code,
               run_type = x$run_type,
               winter_plate_id = x$winter_plate_id,
               spring_plate_id = x$spring_plate_id
    )
  })
}

#' @title Parse Comment for EBK Flags
#' @description
#' Parse plate comment and extract plate related information for EBK id's that fail the qa/qc check
#' @param flag_text string to parse
#' @param flag_type what flag to parse for
#'
#' @export
parse_plate_flags <- function(flag_text, flag_type) {


  re_str <- switch(tolower(flag_type),
                   "ebk" = "(EBK-\\d+-\\d+)_(\\d+)")

  matches <- str_match_all(flag_text, re_str)[[1]]
  as.data.frame(matches[, 2:3, drop = FALSE]) |>
    tidyr::separate(V1, into = c("flag_type","sub_plate", "replicate"), sep= "-") |>
    dplyr::rename(value = V2)
}
