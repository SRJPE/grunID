#' @title Add Thresholds to Database
#' @param con a connection the database
#' @param thresholds a thresholds table to use as insert data, this table is generated by `generate_threshold`
#' @param .control_id the id to use as the control for thresholds
#' @details
#' Additional details...
#'
#' @export
#' @md
add_plate_thresholds <- function(con, thresholds, destination_table, results_table, .control_id = "EBK") {

  if (!DBI::dbIsValid(con)) {
    stop("Connection argument does not have a valid connection the run-id database.
         Please try reconnecting to the database using 'DBI::dbConnect'",
         call. = FALSE)
  }

  plate_run <- unique(thresholds$plate_run_id)
  runtime <- unique(thresholds$runtime)
  if (length(plate_run) > 1) {
    stop("TODO")
  }

  if (length(runtime) > 1) {
    stop("TODO")
  }

  # check if the plate run already exists in the assay_results
  this_plate_run_exists_in_results <- nrow(
    dplyr::collect(dplyr::tbl(con, "assay_result") |> dplyr::filter(plate_run_id == plate_run))
  )

  if (this_plate_run_exists_in_results) {
    stop("the plate run you are trying to upload already exists in the database", call. = FALSE)
  }

  detection_results <- dplyr::tbl(con, results_table) |>
    dplyr::filter(plate_run_id == plate_run,
                  sample_id != .control_id,
                  time == runtime) |>
    dplyr::collect() |>
    dplyr::left_join(thresholds, by = c("assay_id" = "assay_id", "plate_run_id" = "plate_run_id")) |>
    dplyr::mutate(positive_detection = raw_fluorescence > threshold) |>
    dplyr::select(sample_id, assay_id, raw_fluorescence,
                  threshold, positive_detection, plate_run_id, sub_plate)

  assay_results_added <- insert_detection_results(con, detection_results, table = destination_table)

  return(assay_results_added)

}

insert_detection_results <- function(con, detection_results, table = c("assay_result", "external_assay_result")) {

  destination_table <- match.arg(table)

  query <- glue::glue_sql("
  INSERT INTO {`destination_table`} (sample_id, assay_id, raw_fluorescence, threshold,
                            positive_detection, plate_run_id, sub_plate)
  VALUES (
          {detection_results$sample_id},
          {detection_results$assay_id},
          {detection_results$raw_fluorescence},
          {detection_results$threshold},
          {detection_results$positive_detection},
          {detection_results$plate_run_id}::int,
          {detection_results$sub_plate}::int
  );", .con = con)

  assay_results_added <- purrr::map_dbl(query, function(q) {
    DBI::dbExecute(con, q)
  },
  .progress = list(
    type = "iterator",
    clear = FALSE,
    name = "inserting threshold result into database"
  ))

  return(sum(assay_results_added))
}




#' @title Determine Run identifcation after Early and Late Assays
#' @param con a database connection
#' @param sample_id the sample id to perform run identification on
#' @param strategy the strategy to use when multi same assays are found for a sample see "details" for more
#' @details
#' The system allows users to submit as many assays per sample as desired, however at the end in order to assign
#' a genetic run type to a sample a single early, late, spring, and winter assay must be used. The selection
#' strategy gives the function a way to select when it finds multiple assays for a sample.
#'
#' - "positive priority" - will choose the the positive results from the available assays needed
#' - "recent priority" - will choose the most recent assays from the available assays needed.
#' @export
#' @md
ots_early_late_detection <- function(con, sample_id, results_table,
                                     selection_strategy = c("recent priority", "positive priority")) {
  selection_strategy <- match.arg(selection_strategy)

  # get all results that match this sample id
  # we filter to just the sample that have an active plate run associated with them
  assay_results <- tbl(con, results_table) |>
    filter(sample_id == !!sample_id, active == TRUE)

  # get all the assays run for each
  assays_existing_for_sample <- assay_results |> dplyr::distinct(assay_id) |> dplyr::pull()

  # check if assay 1 and 2 exists for each of these
  assay_needed_not_found <- which(!(1:2 %in% assays_existing_for_sample ))

  # check for what assays are needed
  if (length(assay_needed_not_found) > 0) {

    if (length(assay_needed_not_found) == 2) { # both are missing
      cli::cli_warn(c(
        "x" = "late and early assay needed to run early/late detection but assay = {assay_needed_not_found} was not found for sample {sample_id}"
      ))
      return(list(
        sample_id = sample_id,
        status_code = "created",
        run_type = NA_character_,
        early_plate = NA,
        late_plate = NA
      ))
    } else if (assay_needed_not_found == 1) {
      cli::cli_warn(c(
        "x" = "early assay needed to run early/late detection but assay = {assay_needed_not_found} was not found for sample {sample_id}"
      ))
      return(list(
        sample_id = sample_id,
        status_code = "ots28 in progress",
        run_type = NA_character_,
        early_plate = NA,
        late_plate = NA
      ))
    } else if (assay_needed_not_found == 2){
      cli::cli_warn(c(
        "x" = "late assay needed to run early/late detection but assay = {assay_needed_not_found} was not found for sample {sample_id}"
      ))
      return(list(
        sample_id = sample_id,
        status_code = "ots28 in progress",
        run_type = NA_character_,
        early_plate = NA,
        late_plate = NA
      ))
    }
  }

  ots_early <- assay_results |> filter(assay_id == 1)

  if (nrow(collect(ots_early)) > 1) {
    cli::cli_alert_info("using '{selection_strategy}' to identify a unique assay run")
    if (selection_strategy == "positive priority") {
      ots_early_priority_results <-
        ots_early |> filter(positive_detection) |>
        arrange(desc(created_at)) |>
        head(1) |>
        collect()
      if (nrow(ots_early_priority_results) > 1) {
        cli::cli_abort(c(
          "x" = "'positive priority' did not identify a unique assay run",
          "i" = "try a different strategy or pass plate id of run to use for identification"
        ))
      }
    } else if (selection_strategy == "recent priority") {
      ots_early_priority_results <-
        ots_early |> arrange(desc(created_at)) |>
        head(1) |>
        collect()
    }
  } else {
    ots_early_priority_results <- collect(ots_early)
  }




  ots_late <- assay_results |> filter(assay_id == 2)

  if (nrow(collect(ots_late)) > 1) {
    cli::cli_alert_info("using '{selection_strategy}' to identify a unique assay run")
    if (selection_strategy == "positive priority") {
      ots_late_priority_results <-
        ots_late |> filter(positive_detection) |>
        collect()
      # if this results in more than one, abort with error
      if (nrow(ots_late_priority_results) > 1) {
        cli::cli_abort(c(
          "x" = "'positive priority' did not identify a unique assay run",
          "i" = "try a different strategy or pass plate id of run to use for identification"
        ))
      }
      # if this results in no positive then return
      else if (nrow(ots_late_priority_results) == 0) {
        cli::cli_abort(c(
          "x" = "'positive priority' did not yield any results",
          "i" = "no results from this query typically means that there are no positive detections for this sample, you can use 'recent priority' to run genetic identification on whatever the most recent sample results are."
        ))
      }
    } else if (selection_strategy == "recent priority") {
      ots_late_priority_results <-
        ots_late |> arrange(desc(created_at)) |>
        head(1) |>
        collect()
    }
  } else {
    ots_late_priority_results <- collect(ots_late)
  }

  # positive late negative early --> late/fall run
  if (!ots_early_priority_results$positive_detection && ots_late_priority_results$positive_detection) {
    return(list(sample_id = sample_id, status_code = "analysis complete", run_type="FAL", early_plate = ots_early_priority_results$plate_run_id, late_plate = ots_late_priority_results$plate_run_id))
  }
  # positive late and positive early --> HET more testing needed
  else if (ots_early_priority_results$positive_detection && ots_late_priority_results$positive_detection) {
    return(list(sample_id = sample_id, status_code = "analysis complete", run_type="EL-HET", early_plate = ots_early_priority_results$plate_run_id, late_plate = ots_late_priority_results$plate_run_id))
  }
  # negative late and positive early --> SPW need ots 16
  else if (ots_early_priority_results$positive_detection && !ots_late_priority_results$positive_detection) {
    return(list(sample_id = sample_id, status_code = "need ots16", run_type = "SPW", early_plate = ots_early_priority_results$plate_run_id, late_plate = ots_late_priority_results$plate_run_id))
  }
  # negative late and negative early --> UNK
  else if (!ots_early_priority_results$positive_detection && !ots_late_priority_results$positive_detection){
    return(list(sample_id = sample_id, status_code = "EL-failed", run_type = "UNK", early_plate = ots_early_priority_results$plate_run_id, late_plate = ots_late_priority_results$plate_run_id))
  }
  else {
    cli::cli_abort(c("x" = "uknown combination of test results for {sample_id}, unable to proceed"))
  }

}


#' @title Determine Run identifcation after Spring and Winter Assays
#' @param con a database connection
#' @param sample_id the sample id to perform run identification on
#' @param strategy the strategy to use when multi same assays are found for a sample see "details" for more
#' @details
#' The system allows users to submit as manu assays per sample as desired, however at the end in order to assign
#' a genetic run type to a sample a single early, late, spring, and winter assay must be used. The selection
#' strategy gives the function a way to select when it finds multiple assays for a sample.
#'
#' - "positive priority" - will choose the the postitive results from the available assays needed
#' - "recent prioritt" - will choose the most recent assays from the available assays needed.
#' @export
#' @md
ots_winter_spring_detection <- function(con, sample_id, results_table,
                                        selection_strategy = c("positive priority", "recent priority")) {
  selection_strategy <- match.arg(selection_strategy)


  assay_results <- tbl(con, results_table) |>
    filter(sample_id == !!sample_id, active == TRUE)

  assays_for_existing_for_sample <- assay_results |> dplyr::distinct(assay_id) |> dplyr::pull()
  assays_3_for_sample <- assay_results |> dplyr::filter(assay_id == 3) |> dplyr::collect()
  assays_4_for_sample <- assay_results |> dplyr::filter(assay_id == 4) |> dplyr::collect()

  if ((nrow(assays_3_for_sample) == 0) && (nrow(assays_4_for_sample) == 0)) {
    cli::cli_warn(c(
      "x" = "spring and winter assay not found for sample {sample_id}, setting status to 'need-ots16'"
    ))

    return(list(
      sample_id = sample_id,
      status_code = "need ots16",
      run_type = "SPW",
      spring_plate_id = NA_integer_,
      winter_plate_id = NA_integer_
    ))
  } else if (nrow(assays_3_for_sample) == 0 && (nrow(assays_4_for_sample) > 0)) {
    cli::cli_warn(c(
      "x" = "spring and winter assay needed to run spring/winter detection but assay = 3 was not found for sample {sample_id}"
    ))

    return(list(
      sample_id = sample_id,
      status_code = "ots16 inprogress",
      run_type = "SPW",
      spring_plate_id = NA_integer_,
      winter_plate_id = NA_integer_
    ))
  } else if (nrow(assays_4_for_sample) == 0 && (nrow(assays_3_for_sample) > 0)) {
    cli::cli_warn(c(
      "x" = "spring and winter assay needed to run spring/winter detection but assay = 4 was not found for sample {sample_id}"
    ))

    return(list(
      sample_id = sample_id,
      status_code = "ots16 inprogress",
      run_type = NA_character_,
      spring_plate_id = NA_integer_,
      winter_plate_id = NA_integer_
    ))
  }


  # at this point the sample has both 3 an 4, we do selection strategy here
  ots_spring <- assay_results |> dplyr::filter(assay_id == 3)


  if (nrow(collect(ots_spring)) > 1) {
    cli::cli_alert_info("using '{selection_strategy}' to identify a unique assay run")
    if (selection_strategy == "positive priority") {
      ots_spring_priority_results <-
        ots_spring |> filter(positive_detection) |>
        collect()
      if (nrow(ots_early_priority_results) > 1) {
        cli::cli_abort(c(
          "x" = "'positive priority' did not identify a unique assay run",
          "i" = "try a different strategy or pass plate id of run to use for identification"
        ))
      }
    } else if (selection_strategy == "recent priority") {
      ots_spring_priority_results <-
        ots_spring |> arrange(desc(created_at)) |>
        head(1) |>
        collect()
    }
  } else {
    ots_spring_priority_results <- collect(ots_spring)
  }




  ots_winter <- assay_results |> filter(assay_id == 4)

  if (nrow(collect(ots_winter)) > 1) {
    cli::cli_alert_info("using '{selection_strategy}' to identify a unique assay run")
    if (selection_strategy == "positive priority") {
      ots_winter_priority_results <-
        ots_winter |> filter(positive_detection) |>
        collect()
      if (nrow(ots_winter_priority_results) > 1) {
        cli::cli_abort(c(
          "x" = "'positive priority' did not identify a unique assay run",
          "i" = "try a different strategy or pass plate id of run to use for identification"
        ))
      }
    } else if (selection_strategy == "recent priority") {
      ots_winter_priority_results <-
        ots_winter |> arrange(desc(created_at)) |>
        head(1) |>
        collect()
    }
  } else {
    ots_winter_priority_results <- collect(ots_winter)
  }

  # positive winter and negative spring ---> WIN
  if (!ots_spring_priority_results$positive_detection && ots_winter_priority_results$positive_detection) {
    return(list(sample_id = sample_id, status_code = "analysis complete", run_type="WIN",
                winter_plate_id = ots_winter_priority_results$plate_run_id, spring_plate_id = ots_spring_priority_results$plate_run_id))
  }
  # positive winter and positive spring ---> HET
  else if (ots_spring_priority_results$positive_detection && ots_winter_priority_results$positive_detection) {
    return(list(sample_id = sample_id, status_code = "analysis complete", run_type="SW-HET",
                winter_plate_id = ots_winter_priority_results$plate_run_id, spring_plate_id = ots_spring_priority_results$plate_run_id))
  }
  # negative winter and positive spring --> SPR
  else if (ots_spring_priority_results$positive_detection && !ots_winter_priority_results$positive_detection) {
    return(list(sample_id = sample_id, status_code = "analysis complete", run_type = "SPR",
                winter_plate_id = ots_winter_priority_results$plate_run_id, spring_plate_id = ots_spring_priority_results$plate_run_id))
  }
  # both negative --> UNK
  else if (!ots_spring_priority_results$positive_detection && !ots_winter_priority_results$positive_detection){
    return(list(sample_id = sample_id, status_code = "SW-failed", run_type = "UNK",
                winter_plate_id = ots_winter_priority_results$plate_run_id, spring_plate_id = ots_spring_priority_results$plate_run_id))
  }


}

#' @title Run genetic identification
#' @param con a connection to the database
#' @param sample_id optional sample id to run identification on
#' @param location optional location to identification on
#' @param year optional year to identification on
#' @param selection_strategy a selection strategy to help resolve cases where many assays exists per sample
#' @export
run_genetic_identification <- function(con, sample_id = NULL, location = NULL, year = NULL, selection_strategy = "positive priority",
                                       plate_comment, destination_table, sample_table, results_table,
                                       sample_status_table) {

  # check for valid inputs and data -------------------------
  if (is.null(year)) {
    year <- as.integer(format(Sys.Date(), "%Y"))
  }

  if (!is.null(sample_id)) {

    sample_to_run_on <- dplyr::tbl(con, sample_table) |>
      dplyr::filter(id %in% sample_id) |>
      dplyr::collect()

    if (nrow(sample_to_run_on) == 0) {
      cli::cli_abort(c("x" = "location specified did not return any data"))
    }
  } else if (!is.null(location)) {

    query <- glue::glue_sql("select distinct(sample.id), sample_location.code from sample
    join sample_bin on sample.sample_bin_id = sample_bin.id
    join sample_event on sample_bin.sample_event_id = sample_event.id
    join sample_location on sample_event.sample_location_id = sample_location.id
where date_part('year', sample_event.first_sample_date) = {year} and sample_location.code = {location}", .con = con)

    res <- DBI::dbSendQuery(con, query)
    sample_to_run_on <- DBI::dbFetch(res)
    DBI::dbClearResult(res)

    if (nrow(sample_to_run_on) == 0) {
      cli::cli_abort(c("x" = "location specified did not return any data"))
    }
  }

  # run early/late detection on each sample -------------------
  early_late_resp <- purrr::map(
    sample_to_run_on$id, ~ots_early_late_detection(con, ., results_table = results_table, selection_strategy = selection_strategy),
    .progress = list(
      type = "iterator",
      name = "running early late detections",
      clear = FALSE
    ))

  early_late_resp_data <- parse_detection_results(early_late_resp)
  all_status_codes <- grunID::get_status_codes(con)
  all_run_type_id <- grunID::get_run_types(con)

  # updates status code to complete
  status_code_name_to_id <- all_status_codes$id
  names(status_code_name_to_id) <- all_status_codes$status_code_name

  # updates run type
  run_type_name_to_id <- all_run_type_id$id
  names(run_type_name_to_id) <- all_run_type_id$code


  el_failed_status_insert <- early_late_resp_data |>
    filter(status_code == "EL-failed")

  if (nrow(el_failed_status_insert) > 0) {
    el_failed_status_insert$comment <- plate_comment
    el_failed_status_insert$status_code_id <- status_code_name_to_id["EL-failed"]
    status_to_insert <- dplyr::select(el_failed_status_insert, sample_id, status_code_id, comment)
    DBI::dbAppendTable(con, sample_status_table, status_to_insert)

    uknown_gen_insert <- early_late_resp_data |>
      dplyr::filter(status_code == "EL-failed")

    insert_gen_id_to_database(con, uknown_gen_insert, run_type_name_to_id, destination_table)

  }


  analysis_complete_status_insert <- early_late_resp_data |>
    dplyr::filter(status_code == "analysis complete")



  if (nrow(analysis_complete_status_insert) > 0) {

    analysis_complete_status_insert$comment <- plate_comment
    analysis_complete_status_insert$status_code_id <- status_code_name_to_id["analysis complete"]
    analysis_complete_status_insert <- dplyr::select(analysis_complete_status_insert, sample_id, status_code_id, comment)
    DBI::dbAppendTable(con, sample_status_table, analysis_complete_status_insert)

    analysis_complete_gen_insert <- early_late_resp_data |>
      dplyr::filter(status_code == "analysis complete")

    insert_gen_id_to_database(con, analysis_complete_gen_insert, run_type_name_to_id, destination_table = destination_table)

  }

  # at this point we have inserted all of the samples that were complete
  # now check for status = "Created", some of these will need to have genetic id updated, specifically the UNK ones
  created_status_to_insert <-
    early_late_resp_data |> dplyr::filter(status_code == "created")

  if (nrow(created_status_to_insert) > 0) {

    created_status_to_insert$comment <- plate_comment
    created_status_to_insert$status_code_id <- status_code_name_to_id["created"]
    created_status_to_insert <- dplyr::select(created_status_to_insert, sample_id, status_code_id, comment)
    DBI::dbAppendTable(con, sample_status_table, created_status_to_insert)

    # for sample status with "created" the run type needs to be set to UNK so they can be discovered
    unknown_gen_to_insert <- early_late_resp_data |>
      filter(run_type == "UNK")

    if (nrow(unknown_gen_to_insert) > 0) {

      insert_gen_id_to_database(con, unknown_gen_to_insert, run_type_name_to_id, destination_table = destination_table)

    }
  }

  # OTS28 in progress / eihter assay 1 or 2 is not done


  ots28_inprogress_to_insert <- early_late_resp_data |>
    dplyr::filter(status_code == "ots28 in progress")

  if (nrow(ots28_inprogress_to_insert) > 0) {


    ots28_inprogress_to_insert$comment <- plate_comment
    ots28_inprogress_to_insert$status_code_id <- status_code_name_to_id["ots28 in progress"]
    ots28_inprogress_to_insert <- dplyr::select(ots28_inprogress_to_insert, sample_id, status_code_id, comment)
    DBI::dbAppendTable(con, sample_status_table, ots28_inprogress_to_insert)

  }

  # needs ots 16 will be passed into function that tries to assign run based on assay 3 and 4
  ots16_in_progress_to_insert <- early_late_resp_data |>
    dplyr::filter(status_code == "need ots16")

  # TODO - what should we return in this case? For now just returning the dataframe with most info
  if (nrow(ots16_in_progress_to_insert) == 0) {
    return(early_late_resp_data)
  }

  spring_winter_resp <- purrr::map(
    ots16_in_progress_to_insert$sample_id , ~ots_winter_spring_detection(con, ., selection_strategy = selection_strategy, results_table = results_table),
    .progress = list(
      type = "iterator",
      name = "running spring/winter detections",
      clear = FALSE
    ))

  spring_winter_resp_data <- parse_spring_winter_detection_results(spring_winter_resp) |>
    dplyr::left_join(select(early_late_resp_data, sample_id, early_plate, late_plate), by = "sample_id")

  sw_failed_status_insert <- early_late_resp_data |>
    filter(status_code == "SW-failed")

  if (nrow(sw_failed_status_insert) > 0) {
    sw_failed_status_insert$comment <- plate_comment
    sw_failed_status_insert$status_code_id <- status_code_name_to_id["SW-failed"]
    status_to_insert <- dplyr::select(sw_failed_status_insert, sample_id, status_code_id, comment)
    DBI::dbAppendTable(con, sample_status_table, status_to_insert)

    uknown_gen_insert <- early_late_resp_data |>
      dplyr::filter(status_code == "SW-failed")

    insert_gen_id_to_database(con, uknown_gen_insert, run_type_name_to_id, destination_table)

  }


  sw_analysis_complete_status_insert <- spring_winter_resp_data |>
    dplyr::filter(status_code == "analysis complete")

  # if any of the detection results in gen id for spring or winter then update here
  if (nrow(sw_analysis_complete_status_insert) > 0) {

    sw_analysis_complete_status_insert$comment <- plate_comment
    sw_analysis_complete_status_insert$status_code_id <- status_code_name_to_id["analysis complete"]
    sw_analysis_complete_status_insert <- dplyr::select(sw_analysis_complete_status_insert, sample_id, status_code_id, comment)
    DBI::dbAppendTable(con, sample_status_table, sw_analysis_complete_status_insert)

    sw_analysis_complete_gen_insert <- spring_winter_resp_data |>
      dplyr::filter(status_code == "analysis complete")

    insert_gen_id_to_database(con, sw_analysis_complete_gen_insert, run_type_name_to_id, destination_table = destination_table)

  }

  # need ots 16
  ots16_need_inserts <- spring_winter_resp_data |>
    dplyr::filter(status_code == "need ots16")

  if (nrow(ots16_need_inserts) > 0) {
    ots16_need_inserts$comment <- plate_comment
    ots16_need_inserts$status_code_id <- status_code_name_to_id["need ots16"]
    ots16_need_inserts <- dplyr::select(ots16_need_inserts, sample_id, status_code_id, comment)
    DBI::dbAppendTable(con, sample_status_table, ots16_need_inserts)

    spw_gen_to_insert <- spring_winter_resp_data |>
      filter(run_type == "SPW")

    if (nrow(spw_gen_to_insert) > 0) {
      insert_gen_id_to_database(con, spw_gen_to_insert, run_type_name_to_id, destination_table)
    }
  }

  # ots 16 in progress status updates
  ots16_inprogress_inserts <- spring_winter_resp_data |>
    dplyr::filter(status_code == "ots16 inprogress")

  if (nrow(ots16_inprogress_inserts) > 0 ) {
    ots16_inprogress_inserts$comment <- plate_comment
    ots16_inprogress_inserts$status_code_id <- status_code_name_to_id["ots16 inprogress"]
    ots16_inprogress_inserts <- dplyr::select(ots16_inprogress_inserts, sample_id, status_code_id, comment)
    DBI::dbAppendTable(con, sample_status_table, ots16_inprogress_inserts)

    spw_gen_to_insert <- spring_winter_resp_data |>
      filter(run_type == "SPW")

    if (nrow(spw_gen_to_insert) > 0) {
      insert_gen_id_to_database(con, spw_gen_to_insert, run_type_name_to_id, destination_table = destination_table)
    }


  }



}





#' @keywords internal
insert_gen_id_to_database <- function(con, insert_data, run_lookups, destination_table) {
  # append cols required
  run_type_code <- insert_data$run_type
  insert_data$run_type_id = as.numeric(run_lookups[insert_data$run_type])
  insert_data <- dplyr::select(insert_data, tidyselect::any_of(c("sample_id", "run_type_id", "early_plate", "late_plate", "spring_plate_id", "winter_plate_id")))
  insert_data$updated_at <- lubridate::now(tzone = "UTC")

  purrr::walk(1:nrow(insert_data), function(row) {
    this_sample_id <- insert_data$sample_id[row]
    this_run_type_id <- insert_data$run_type_id[row]
    this_early_plate <- insert_data$early_plate[row]
    this_late_plate <- insert_data$late_plate[row]
    this_spring_plate_id <- insert_data$spring_plate_id[row]
    this_winter_plate_id <- insert_data$winter_plate_id[row]

    insert_statement <- if (run_type_code[row] %in% c("SPW", "SPR", "WIN")) {
      glue::glue_sql(
        "INSERT INTO {`destination_table`} (sample_id, run_type_id, early_plate_id, late_plate_id, spring_plate_id, winter_plate_Id, updated_at)
    VALUES
      ({this_sample_id}, {this_run_type_id}, {this_early_plate}, {this_late_plate}, {this_spring_plate_id}, {this_winter_plate_id}, CURRENT_TIMESTAMP AT TIME ZONE 'UTC')
    ON CONFLICT (sample_id) DO UPDATE
    SET
      run_type_id = EXCLUDED.run_type_id,
      spring_plate_id = EXCLUDED.spring_plate_id,
      winter_plate_id = EXCLUDED.winter_plate_id,
      updated_at = EXCLUDED.updated_at;
    ",
        .con = con
      )
    } else {
      glue::glue_sql(
        "INSERT INTO {`destination_table`} (sample_id, run_type_id, early_plate_id, late_plate_id, updated_at)
    VALUES
      ({this_sample_id}, {this_run_type_id}, {this_early_plate}, {this_late_plate}, CURRENT_TIMESTAMP AT TIME ZONE 'UTC')
    ON CONFLICT (sample_id) DO UPDATE
    SET
      run_type_id = EXCLUDED.run_type_id,
      early_plate_id = EXCLUDED.early_plate_id,
      late_plate_id = EXCLUDED.late_plate_id,
      updated_at = EXCLUDED.updated_at;
    ",
        .con = con
      )
    }

    DBI::dbExecute(con, insert_statement)
  })
}


parse_detection_results <- function(detection_results) {
  purrr::map_df(detection_results, function(x) {
    data.frame(sample_id = x$sample_id,
               status_code = x$status_code,
               run_type = x$run_type,
               early_plate = x$early_plate,
               late_plate = x$late_plate)
  })
}

parse_spring_winter_detection_results <- function(detection_results) {
  purrr::map_df(detection_results, function(x) {
    data.frame(sample_id = x$sample_id,
               status_code = x$status_code,
               run_type = x$run_type,
               winter_plate_id = x$winter_plate_id,
               spring_plate_id = x$spring_plate_id
    )
  })
}

#' @title Parse Comment for EBK Flags
#' @description
#' Parse plate comment and extract plate related information for EBK id's that fail the qa/qc check
#' @param flag_text string to parse
#' @param flag_type what flag to parse for
#'
#' @export
parse_plate_flags <- function(flag_text, flag_type) {


  re_str <- switch(tolower(flag_type),
                   "ebk" = "(EBK-\\d+-\\d+)_(\\d+)")

  matches <- str_match_all(flag_text, re_str)[[1]]
  as.data.frame(matches[, 2:3, drop = FALSE]) |>
    tidyr::separate(V1, into = c("flag_type","sub_plate", "replicate"), sep= "-") |>
    dplyr::rename(value = V2)
}
